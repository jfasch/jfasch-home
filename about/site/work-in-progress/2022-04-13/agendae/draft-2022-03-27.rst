.. include:: <mmlalias.txt>


Agenda (Sent Out 2022-03-27)
============================

.. contents::
   :local:

Overall Plan
------------

.. note::

   **Proposed structure from 2022-03-09**

   * Block 1: Clean code

     * Thoughts from Uncle Bob

       * Bring example
       * Discuss

     * Keeping Code Clean in the Small

   * Block 2: Unit Testing, TDD

     * C/C++: googletest
     * Python: pytest (sketch only)
     * Livehacking and simple project

   * Block 3: TDD hands-on

     * 7 people |longrightarrow| groups
     * Artificial project; it's not easy to find code that can be
       made testable/tested at customer's site.
     * cmake, cdash (?), ctest, visual studio (2019, doze)
     * In-house tools for unittests?

       * cdk (core development kit) testsystem (home-made, unwanted
         internally)
       * https://robotframework.org/ -> jenkins

     * Create two dummy projects googletest and boost, try to build
       those

*Live-hack*, and bring up an artificial project step by step, to give
an overview of the following topics.

.. list-table::
   :align: left

   * * .. image:: ../images/clean-code.jpg
     * `Clean Code: A Handbook of Agile Software Craftsmanship, by
       Robert C. Martin ("Uncle Bob")
       <https://www.oreilly.com/library/view/clean-code-a/9780136083238/>`__
   * * .. image:: ../images/tdd.jpg
     * `Test Driven Development: By Example, by Kent Beck
       <https://www.oreilly.com/library/view/test-driven-development/0321146530/>`__

The project starts small, introducing :doc:`Unit Testing and Test
Driven Development </trainings/repertoire/unittests>`.

By throwing more and more requirements at the project as we go, ideas
from the Clean Code book are demonstrated.

Using slide material, guide through an agile process based on test
driven development on that project.

User Database: The Beginning 
----------------------------

.. sidebar::

   **Goal**

   * Establish an initial code base
   * That is the problem
   * |longrightarrow| *it has a bug*

Implementation
..............

* ``class User``, like I did, for example, in
  :doc:`/trainings/log/detail/2022-03-15/index` - only in C++.
* A brute force user database, at first: ``using UserDB =
  std::map<std::string, User>;``
* Readers and writers. Hardcoded first, via if/else configurable by
  their names.
* First implementation: raw file, writing out fixed-size
  records. *Live hack that* (maybe pull in little code snippets), to
  demonstrate how the problem is created.

  .. code-block:: c++

     struct BinaryUser {
         char firstname[10];
         char lastname[10];
         char email[20];
     };
     void write(std::ofstream&)
     {
         // ... put ``User`` object's members into ``BinaryUser``, 
         // not caring too much about array sizes
     }
   
Enter Unit Testing
------------------

Plan
....

* First few tests come about when something goes wrong.
* Write separate programs for each
* Run them with an inline shell loop on the commandline
* Then switch to a python script, using subprocess to report failure
  and crash (-> exit codes), and capture stdout and stderr with a
  argparse option. Prepare that, explain a little.

First Test: A Bug Comes In
--------------------------

.. sidebar::

   **Goal**

   * Introduce Unit Testing at a very low level

* Raw file implementation has a bug: ``char[]`` overflow check
  missing. A number of tests using the same :doc:`fixture
  </trainings/material/soup/unittest/unittest_gtest_fixture/screenplay>`,
  basically
* This is our first test |longrightarrow| *Live hack it*
* Handwritten first, like 

  .. code-block:: c++
     :caption: ``int main(void)``
  
     UserDB db;
     db.push_back(User{"Joerg", "Faschingbauer", "email@me.com"});
     db.push_back(User{"A", "Colleage", "email@them.com"});
     char filename[] = "my-first-testXXXXXX";
     int fileno = mkstemp(filename);
     std::ofstream ofs(filename, std::ofstream::out);
     db.write(ofs);
     ofs.close();
     
     std::string content = read_entire_file_content_into_memory(filename);
     if (content[20] != 'e') {
         std::cerr << "email nix start with 'e' << std::endl;
         return 1;
     }
     return 0;

* |longrightarrow| ``UserDB db``, together with setup, defined inside
  that test file.

  * Re-use is not a matter now
  * A :ref:`second test <second-test>`, later, when a feature is
    implemented using Test Driven Development, we will factor that
    code out.
	   
* Fix `valgrind <https://valgrind.org/>`__ detected file descriptor
  leak when done

.. _second-test:

Second Test: A Requirement Comes In
-----------------------------------

.. sidebar::
   
   **Goal**

   * Problem of test organization becomes apparent
		
Raw file formats are only used in mainframes nowadays. People want
something more modern: plaintext files. :doc:`/me
</about/myself/index>` grumbles about customer.

* Think about user database. 
* Write a test for the reader ``UserDB`` setup, again.

  .. code-block:: c++
     :caption: ``int main(void)``
     
     static std::string EXPECTED_CONTENT = "Joerg;Faschingbauer;email@me.com\n"
                                           "A:Colleage:email@them.com\n";
     
     User user;
     UserDB db;
     db.push_back(User{"Joerg", "Faschingbauer", "email@me.com"});
     db.push_back(User{"A", "Colleage", "email@them.com"});
     char filename[] = "my-first-testXXXXXX";
     int fileno = mkstemp(filename);
     std::ofstream ofs(filename, std::ofstream::out);
     db.write_plaintext(ofs);
     
     std::string content = read_entire_file_content_into_memory(filename);
     if (content != EXPECTED_CONTENT)
         return 1; // UNIX program exit status
     return 0;

* Implement the feature so that the first test runs through. Simply
  pull in an implementation from snippets.
* Write another test, this time for the reader side. Now it's the
  third time that we fill our user database so verbosely.

Restructure Test Code: Enter Unit Testing Frameworks
----------------------------------------------------

.. sidebar:: 

   **Goal**

   * Show one Unit Testing Framework, ``googletest``

   **Links**

   * :doc:`/trainings/material/soup/unittest/unittest_gtest_basics/screenplay`
   * :doc:`/trainings/material/soup/unittest/unittest_gtest_cmake/screenplay`
   * :doc:`googletest-instructions`
   * `googletest <https://github.com/google/googletest>`__

* Factor out ``UserDB`` instances from both tests, this is duplicate
  code |longrightarrow| *not clean*
* Provide a global variable and a ``setup_fixture(std::vector)`` (*by
  copy*, provocantly [#rvalue-ref]_) in ``userdb-fixture.{h.cpp}``)
* Use that instead in all three tests

More tests ...

* Write another test for the reader (error checking, this time). "No
  separator found!", for example.
* Create *test suites*, to group together related tests into separate
  file, and run them as part of *one binary per test suite*. Goal:

  .. code-block:: console

     $ for test in $(ls -1 test-*); do $test && echo "SUCCESS: $test" 1>&2 || echo "FAILED: $test" 1>&2; done

Enter Unit Testing Frameworks
-----------------------------


Implementation
..............

* Transform existing test code to use `googletest
  <https://github.com/google/googletest>`__
* Complain loudly about `this
  <https://google.github.io/googletest/advanced.html#type-assertions>`__. Tested
  code should not contain test code.

More Unit Testing Frameworks
............................

Overview of other unit testing frameworks.

* C/C++: `Boost.Test
  <https://www.boost.org/doc/libs/1_66_0/libs/test/doc/html/index.html>`__
* `CMake's CTest <https://docs.pytest.org/en/7.0.x/>`__: how does that
  fit in?
* Python: :doc:`python:library/unittest`
* Python: `pytest <https://docs.pytest.org/>`__
  

More Requirements: Clean Code, Large And Small
----------------------------------------------

Come up with a series of requirements, giving us the chance to shine
light on the following topics.

Cornerstones From The "Clean Code" Book
.......................................


* Software development cycle (*not (!!)*: waterfall)
* Requirements

  * At a small scale, tests are easy. Mocking a database away maybe?
    New reader/writer.
  * Lost tests? Do ``CMake`` and ``googletest`` help in this regard?

* *Intuitive* implementation (|longrightarrow| respect from co-workers
  and oneself)
* Refactoring: removing unclean code and *not* breaking requirements

  E.g., factor out readers and writers in an interface, and separate.

* Craftsmanship? 
* **Maintainability?**
* Bonus topics about code structure [#code-structure]_, maybe

Keeping Code Clean in the Small
................................

C Language Support for Code Sanity
``````````````````````````````````

See :doc:`/trainings/material/soup/c/090-program-sanity/group` for
available slide material.

* ``const`` correctness
* ``static``: constraining global visibility (anonymous namespaces do
  the same job)
* Integer sizes and signedness
* Advanced techniques

Compiler Warning and Error Options
``````````````````````````````````

Talk about GCC/LLVM's options to enable warnings on suspicious code.

Optimization
````````````

*
  :doc:`/trainings/material/soup/c/100-performance/020-computebound/topic`. Show
  what compilers usually can do for you, performance-wise (message:
  they are better at writing ugly code than any human).


*
  :doc:`/trainings/material/soup/c/100-performance/030-memory/topic`. Memory
  optimization: Caches, array traversal

Hands-On: More Requirements
---------------------------

.. sidebar::

   **Goal**

   * Switch to group exercise mode: can we work together on a version
     control system?
   * Github maybe? Can we have per-user accounts?
   * Or can I join your organization?
   * :doc:`googletest-instructions`

Conclusion/Message
------------------

* Unit Testing makes code clean from beginning
* Refactoring is done as needed (no fear of breakage)
* Part of software craftsmanship


.. rubric:: Footnotes

.. [#rvalue-ref] If somebody asks, talk about :doc:`C++ 11 move
                 semantics
                 </trainings/material/soup/cxx11/020-new-language-features/060-move/group>`
                 |:wink:|

.. [#code-structure] 

   * What's a "module"?
   * *Dependency management*
   
     * Modules depend on others
     * Often the *why* is unknown |longrightarrow| "just happened"
     * *Dependency Inversion*: depending on *interfaces* rather than
       *implementations*
     * ``cmake --graphviz=...``
   
   * Road to hell: *cyclic dependencies* and *global variables*

