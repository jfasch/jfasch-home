.. include:: <mmlalias.txt>


Agenda (Sent Out 2022-03-29)
============================

.. contents::
   :local:
   :depth: 2

Overall Plan
------------

* Take the topics from the :doc:`proposed agenda <proposed-structure>`
  ("Clean Code", TDD, and a hands-on session)
* Establish an artificial project, in a *live-hacking mode* (:doc:`/me
  </about/myself/index>` hacks and talks, and brings up slide material
  occasionally)

  * First implementation of core functionality
  * Introduce a brute force testing approach (which is then also used
    for feature development/TDD)
  * Switch to ``googletest``

* Overview of the "Clean Code" book (see below)
* Hands-On session in the afternoon. Refactoring to clean code,
  feature implementation, ...

.. list-table::
   :align: left

   * * .. image:: ../images/clean-code.jpg
     * `Clean Code: A Handbook of Agile Software Craftsmanship, by
       Robert C. Martin ("Uncle Bob")
       <https://www.oreilly.com/library/view/clean-code-a/9780136083238/>`__
   * * .. image:: ../images/tdd.jpg
     * `Test Driven Development: By Example, by Kent Beck
       <https://www.oreilly.com/library/view/test-driven-development/0321146530/>`__

09:00-11:00: Establishing The Project (Live Hacking, Slides)
------------------------------------------------------------

The Beginning 
..............

.. sidebar::

   **Goal**

   * Establish an initial code base
   * That is the problem
   * |longrightarrow| *it has a bug*

Implementation Notes
````````````````````

* ``class User``, like I did, for example, in
  :doc:`/trainings/log/detail/2022-03-15/index` - only in C++.
* A brute force user database, at first: ``using UserDB =
  std::map<std::string, User>;``
* Readers and writers. Hardcoded first, via if/else configurable by
  their names.
* First implementation: raw file, writing out fixed-size
  records. *Live hack that* (maybe pull in little code snippets), to
  demonstrate how the problem is created.

  .. code-block:: c++

     struct BinaryUser {
         char firstname[10];
         char lastname[10];     // <--- BUG OPPORTUNITY!! ("Faschingbauer" is longer)
         char email[20];
     };
     void write(std::ofstream&)
     {
         // ... put ``User`` object's members into ``BinaryUser``, 
         // not caring too much about array sizes
     }
   
Enter Unit Testing
..................

Plan
````

* First few tests come about when something goes wrong.
* Write separate programs for each
* Run them with an inline shell loop on the commandline
* Then switch to a python script, using subprocess to report failure
  and crash (-> exit codes), and capture stdout and stderr with a
  argparse option. Prepare that, explain a little.

First Test: A Bug Comes In
..........................

.. sidebar::

   **Goal**

   * Introduce Unit Testing at a very low level

* Raw file implementation has a bug: ``char[]`` overflow check
  missing. A number of tests using the same :doc:`fixture
  </trainings/material/soup/unittest/unittest_gtest_fixture/screenplay>`,
  basically
* This is our first test |longrightarrow| *Live hack it*
* Handwritten first, like 

  .. code-block:: c++
     :caption: ``int main(void)``
  
     UserDB db;
     db.push_back(User{"Joerg", "Faschingbauer", "email@me.com"});
     db.push_back(User{"A", "Colleage", "email@them.com"});
     char filename[] = "my-first-testXXXXXX";
     int fileno = mkstemp(filename);
     std::ofstream ofs(filename, std::ofstream::out);
     db.write(ofs);
     ofs.close();
     
     std::string content = read_entire_file_content_into_memory(filename);
     if (content[20] != 'e') {
         std::cerr << "email nix start with 'e' << std::endl;
         return 1;
     }
     return 0;

* |longrightarrow| ``UserDB db``, together with setup, defined inside
  that test file.

  * Re-use is not a matter now
  * A :ref:`second test <xxx-second-test>`, later, when a feature is
    implemented using Test Driven Development, we will factor that
    code out.
	   
* Fix `valgrind <https://valgrind.org/>`__ detected file descriptor
  leak when done

.. _xxx-second-test:

Second Test: A Requirement Comes In
...................................

.. sidebar::
   
   **Goal**

   * Problem of test organization becomes apparent
		
Raw file formats are only used in mainframes nowadays. People want
something more modern: plaintext files. :doc:`/me
</about/myself/index>` grumbles about customer.

* Think about user database. 
* Write a test for the reader ``UserDB`` setup, again.

  .. code-block:: c++
     :caption: ``int main(void)``
     
     static std::string EXPECTED_CONTENT = "Joerg;Faschingbauer;email@me.com\n"
                                           "A:Colleage:email@them.com\n";
     
     User user;
     UserDB db;
     db.push_back(User{"Joerg", "Faschingbauer", "email@me.com"});
     db.push_back(User{"A", "Colleage", "email@them.com"});
     char filename[] = "my-first-testXXXXXX";
     int fileno = mkstemp(filename);
     std::ofstream ofs(filename, std::ofstream::out);
     db.write_plaintext(ofs);
     
     std::string content = read_entire_file_content_into_memory(filename);
     if (content != EXPECTED_CONTENT)
         return 1; // UNIX program exit status
     return 0;

* Implement the feature so that the first test runs through. Simply
  pull in an implementation from snippets.
* Write another test, this time for the reader side. Now it's the
  third time that we fill our user database so verbosely.

Restructure Test Code
.....................

Without using a unit testing framework (we want to create the problem
first, and then see the solution),

* Factor out ``UserDB`` instances from both tests, this is duplicate
  code |longrightarrow| *not clean*
* Provide a global variable and a ``setup_fixture(std::vector)`` (*by
  copy*, provocantly [#rvalue-ref]_) in ``userdb-fixture.{h.cpp}``)
* Use that instead in all three tests

More tests ...

* Write another test for the reader (error checking, this time). "No
  separator found!", for example.
* Create *test suites*, to group together related tests into separate
  file, and run them as part of *one binary per test suite*. Goal:

  .. code-block:: console

     $ for test in $(ls -1 test-*); do $test && echo "SUCCESS: $test" 1>&2 || echo "FAILED: $test" 1>&2; done

Enter Unit Testing Frameworks
.............................

.. sidebar:: 

   **Goal**

   * Show one Unit Testing Framework, ``googletest``

   **Links**

   * :doc:`/trainings/material/soup/unittest/unittest_gtest_basics/screenplay`
   * :doc:`/trainings/material/soup/unittest/unittest_gtest_cmake/screenplay`
   * :doc:`googletest-instructions`
   * `googletest <https://github.com/google/googletest>`__

* Transform existing test code to use `googletest
  <https://github.com/google/googletest>`__
* Complain loudly about `this
  <https://google.github.io/googletest/advanced.html#type-assertions>`__. Tested
  code should not contain test code.

Overview Of Other Unit Testing Frameworks
`````````````````````````````````````````

* C/C++: `Boost.Test
  <https://www.boost.org/doc/libs/1_66_0/libs/test/doc/html/index.html>`__
* `CMake's CTest <https://docs.pytest.org/en/7.0.x/>`__: how does that
  fit in?
* Python: :doc:`python:library/unittest`
* Python: `pytest <https://docs.pytest.org/>`__

11:00-14:00: Clean Code: What Is That? (Slides Only)
----------------------------------------------------

11:00-12:00: Cornerstones From The "Clean Code" Book
....................................................

* Software development cycle (*not (!!)*: waterfall)
* Requirements

  * At a small scale, tests are easy. Mocking a database away maybe?
    New reader/writer.
  * Lost tests? Do ``CMake`` and ``googletest`` help in this regard?

* *Intuitive* implementation (|longrightarrow| respect from co-workers
  and oneself)
* Refactoring: removing unclean code and *not* breaking requirements

  E.g., factor out readers and writers in an interface, and separate.

* Craftsmanship? 
* **Maintainability?**
* Bonus topics about code structure [#code-structure]_, maybe

12:00-13:00: Lunch Break
........................

13:00-14:00: Keeping Code Clean in the Small
............................................

**C Language Support for Code Sanity**

See :doc:`/trainings/material/soup/c/090-program-sanity/group` for
available slide material.

* ``const`` correctness
* ``static``: constraining global visibility (anonymous namespaces do
  the same job)
* Integer sizes and signedness
* Advanced techniques

**Compiler Options: Warnings and Errors**

Talk about GCC/LLVM's options to enable warnings on suspicious code.

**Optimization**

*
  :doc:`/trainings/material/soup/c/100-performance/020-computebound/topic`. Show
  what compilers usually can do for you, performance-wise (message:
  they are better at writing ugly code than any human).

*
  :doc:`/trainings/material/soup/c/100-performance/030-memory/topic`. Memory
  optimization: Caches, array traversal

14:00-??: Hands-On Session
--------------------------

.. sidebar::

   **Goal**

   * Switch to group exercise mode: can we work together on a version
     control system?

   **Open Questions**

   * Github maybe? Can we have per-user accounts?
   * Or can I join your organization?
   * :doc:`googletest-instructions`

In a test driven manner, lets do

* Refactoring
* Feature implementation (unclean first, followed by refactoring
  sessions)


.. rubric:: Footnotes

.. [#rvalue-ref] If somebody asks, talk about :doc:`C++ 11 move
                 semantics
                 </trainings/material/soup/cxx11/020-new-language-features/060-move/group>`
                 |:wink:|

.. [#code-structure] 

   * What's a "module"?
   * *Dependency management*
   
     * Modules depend on others
     * Often the *why* is unknown |longrightarrow| "just happened"
     * *Dependency Inversion*: depending on *interfaces* rather than
       *implementations*
     * ``cmake --graphviz=...``
   
   * Road to hell: *cyclic dependencies* and *global variables*


